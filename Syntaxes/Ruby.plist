{
	name = "Ruby";
	scopeName = "source.ruby";
	firstLineMatch = "^#!/.*\\<ruby\\>";
	fileTypes = ( rb, Rakefile, rake, cgi, fcgi );
	
	/*
	TODO: unresolved issues

	text:
	"a\332a"
	symptoms:
	'\332' is not recognized as slash3.. which should be octal 332.
	solution:
	plain regexp.. should be easy.

	text:	
	gsub!(/ +/, '')
	symptoms:
	'/ +/' is recognized as division.. which should be regexp.
	solution:
	there is lots of ambiguity between division and regexp.
	no solution at this moment... difficult.

	text:
	M[1]?(a+b):p(c+d)
	symptoms:  
	'?(' is recognized as an integer.. which its not.
	':p' is recognized as a symbol.. which its not.
	solution:
	requires lookbehind... currently imposible.

	text:
	"1"?"  ":"()"
	symptoms:
	'?"' is recognized as an integer.. which its not.
	'":' is recognized as string begin.. which propagation of earlier error.
	solution:
	requires lookbehind... currently imposible.
	*/

  foldingStartMarker = "^\\s*(def|class|module|([^#])*\\<do\\>)\\>(?!.*\\<end\\>\\s*(#.*)?$)";
  foldingStopMarker = "(^\\s*end|;\\s*end)\\s*(#.*)?$";

	patterns = (
        // everything being a reserved word, not a value and needing a 'end' is a..
		{  name = "keyword.control.ruby";
		   match = "\\<(BEGIN|begin|case|class|else|elsif|END|end|ensure|for|if|in|module|rescue|then|unless|until|when|while)\\>(?![?!])";
		},
		
		// contextual smart pair support for block parameters
		{  name = "keyword.control.ruby.start-block";
		   match = "\\<do\\>\\s*";
		},
		{
		    name = "meta.syntax.ruby.start-block";
            match = "\\{(\\s*)(\\})?";
		},
		
		// as above, just doesn't need a 'end' and does a logic operation
		{  name = "keyword.logical.ruby";
		   match = "\\<(and|not|or)\\>";
		},
		
		// just as above but being not a logical operation
		{  name = "keyword.pseudo-method.ruby";
		   match = "\\<(alias|alias_method|break|next|redo|retry|return|super|undef|yield)\\>(?![?!])|\\<defined\\?";
		},
		
		// every reserved word, being a value is a..
		{  name = "keyword.pseudo-variable.ruby";
         match = "\\<(nil|true|false|__(FILE|LINE)__|self)\\>(?![?!])";
		},
		
		// everything being a method but having a special function is a..
		{  name = "keyword.special-method.ruby";
		   match = "\\<(initialize|new|loop|include|require|raise|attr_reader|attr_writer|attr_accessor|attr|catch|throw|private|public|protected)\\>(?![?!])";
		},
		
		
		{  name = "variable.readwrite.instance.ruby";
		   match = "@[a-zA-Z_]\\w*";
		},
      
		{  name = "variable.readwrite.class.ruby";
		   match = "@@[a-zA-Z_]\\w*";
		},
      
		{  name = "variable.readwrite.global.ruby";
		   match = "\\$[a-zA-Z_]\\w*";
		},
		
		{  name = "variable.readwrite.global.pre-defined.ruby";
		   match = "\\$(!|@|&|`|'|\\+|\\d|~|=|/|\\\\|,|;|\\.|<|>|_|\\*|\\$|\\?|:|\"|-[0adFiIlpv])";
		},
		
		{  name = "variable.constant.ruby";
		   match = "\\<[A-Z]\\w*\\>";
		},
		
		
		// { name = "keyword.constants.regexp.ruby"; match = "\\$(`|\\.|')"; fontStyle = ( bold ); },

		{
		    name = "declaration.function.method.with-arguments.ruby";
		    // the method pattern comes from the symbol pattern, see there for a explaination
		    begin = "\\<(def)\\>\\s+((?>[a-zA-Z_]\\w*(?>\\.|::))?(?>[a-zA-Z_]\\w*(?>[?!]|=(?!>))?|===?|>[>=]?|<[<=]?|<=>|[%&`/\\|]|\\*\\*?|=?~|[-+]@?|\\[\\]=?))\\s*\\(";
		    // this can slow down TM really if you write invalid ruby:
		    // swallow = "\\([^()]*(?R)[^()]*\\)|[^()]*";
		    end = "\\)";
		    patterns = ( { include = "source.ruby"; } );
    	    captures = {    1 = { name = "keyword.blocking.ruby"; };
    	                    2 = { name = "entity.name.function"; }; };
		},
		
		{
		    name = "declaration.function.method.without-arguments.ruby";
		    // the optinal name is just to catch the def also without a method-name
		    match = "\\<(def)\\>(\\s+((?>[a-zA-Z_][\\w?!]*(?>\\.|::))?(?>[a-zA-Z_][\\w*?!](?>[?!]|=(?!>))?|===?|>[>=]?|<[<=]?|<=>|[%&`/\\|]|\\*\\*?|=?~|[-+]@?|\\[\\]=?)))?";
		    captures = {    1 = { name = "keyword.reserved-word.blocking.ruby"; };
		                    3 = { name = "entity.name.function"; }; };
		},

/*		{ 
			name = "keyword.function.identifier.ruby"; match = "[a-z][a-zA-Z0-9_?!]*";
			//foregroundColor = "#FF3333"; 
		},*/

		{ 
			name = "constant.numeric.ruby"; 
//			match = "(\\<((0(x|X)[0-9a-fA-F]*)|(([0-9]+\\.?[0-9]*)|(\\.[0-9]+))((e|E)(\\+|-)?[0-9]+)?)(L|l|UL|ul|u|U|F|f)?\\>)|((?<!\\w)\\?\\S)"; 
			match = "\\<(0[xX][0-9A-Fa-f](?>_?[0-9A-Fa-f])*|\\d(?>_?\\d)*(\\.(?>_?\\d)*)?([eE][-+]?(?>_?\\d)*)?)\\>"; 
		},
			
		{
		    name = "declaration.class.ruby";
		    match = "^\\s*(class)\\s+([.a-zA-Z0-9_:]+(\\s*<\\s*[.a-zA-Z0-9_:]+)?)";
		    captures = {
		        1 = { name = "keyword.blocking.ruby"; };
		        2 = { name = "entity.name.class"; };
		        3 = { name = "entity.parameter.parent.class"; };
		    };
/*			"foregroundColor[1]" = "#CC7833";
			"fontStyle[2]" = ( underline );
			"fontStyle[3]" = ( italic );
*/		},

		/*{ name = "keyword.variable.symbol.ruby"; match = "\\s+(:[a-zA-Z_?!<>]+|:'.*?'?)";
			"foregroundColor[1]" = "#3387CC";
		},*/

		{ name = "constant.symbol.single-quoted.ruby"; begin = ":'"; end = "'"; swallow = "\\\\['\\\\]";},
		{ name = "constant.symbol.double-quoted.ruby"; begin = ":\""; end = "\""; swallow = "\\\\.";
		  patterns = (
		    { name = "string.interpolation.ruby"; begin = "#\\{"; end = "\\}"; patterns = ( { include = "source.ruby"; } ); }
		  );
		},

		{
			/*
			single quoted string (does not allow interpolation):
			'hello #{42} world'   #->  "hello #{42} world"
			*/
			name = "string.single-quoted.ruby"; 
			begin = "'"; 
			end = "'"; 
			swallow = "\\\\."; 
			patterns = (
				{ 
					name = "string.escaped.char.ruby"; 
					match = "\\\\'"; 
				}
			);
		},

	    { 
	    	/*
	    	double quoted string (allows for interpolation):
	    	"hello #{42} world"   #->  "hello 42 world"
	    	"hello #@ivar world"  #->  "hello 42 world"
	    	"hello #@@cvar world" #->  "hello 42 world"
	    	"hello #$gvar world"  #->  "hello 42 world"
	    	*/
			name = "string.double-quoted.ruby"; 
			begin = "\""; 
			end = "\""; 
			swallow = "\\\\."; 
	    	patterns = (
		    	{ name = "string.interpolation.ruby"; begin = "#\\{"; end = "\\}"; patterns = ( { include = "source.ruby"; } ); },
/*	        	{ 
					name = "string.interpolation.ruby"; 
					match = "#(\\{([^\\}]*)\\}|@{1,2}[a-zA-Z0-9_]+|[$][a-zA-Z0-9_]+)"; 
					foregroundColor = "#aaaaaa"; 
				},
*/				{ 
					name = "string.escaped.char.ruby"; 
					match = "\\\\."; 
				}
	    	);
	    },
	    
	    {
	        /*
	        literal string
	        %q{x#{4}x}   #-> 'x#{4}x'
	        */
	        name = "string.single-quoted.ruby.mod";
	        begin = "%q\\{";
	        end = "\\}";
	    },

	    {
	    	/*
	    	literal string (allows for interpolation):
	    	%{x#{4}x}   #-> "x4x"
	    	*/
	    	name = "string.double-quoted.ruby.mod"; 
	    	begin = "%Q?\\{"; 
	    	end = "\\}";
	    	swallow = "\\\\."; 
	    	patterns = (
	        	{ name = "string.interpolation.ruby"; begin = "#\\{"; end = "\\}"; patterns = ( { include = "source.ruby"; } ); }
	      	);
	    },

	    { 
	    	/*
	    	execute string (allows for interpolation):
	    	`ls`   #-> ".\n..\nREADME\nmain.rb"
	    	*/
	    	name = "string.backticked.ruby"; 
	    	begin = "`"; 
	    	end = "`"; 
	    	swallow = "\\\\."; 
	    	patterns = (
	        	{ name = "string.interpolation.ruby"; begin = "#\\{"; end = "\\}"; patterns = ( { include = "source.ruby"; } ); },
	    		{ 
	    			name = "string.escaped.char.ruby"; 
	    			match = "\\\\."; 
	    		}
	    	);
	    },
	    
	    {
	        /*
	        execute string (allow for interpolation):
	        %x{ls}   #-> ".\n..\nREADME\nmain.rb"
	        */
	        name = "string.backticked.ruby.mod";
	        begin = "%x\\{";
	        end = "\\}";
	        swallow = "\\\\.";
	        patterns = (
	            { name = "string.interpolation.ruby"; begin = "#\\{"; end = "\\}"; patterns = ( { include = "source.ruby"; } ); },
	            {
	                name = "string.escaped.char.ruby";
	                match = "\\\\.";
	            }
	        );
	    },
	
	    {
			/*
			regular expressions (normal):
			/<regexp>/<options>
			*/
			name = "string.regexp.ruby.classic"; 
			begin = "/(?=\\S.*/)"; 
			end = "/[eimnosux]*";
			swallow = "\\\\."; 
	    	patterns = (
	        	/*{
					name = "string.interpolation.ruby"; 
					match = "#\\{([^\\}]*)\\}"; 
				},*/
				{ name = "string.interpolation.ruby"; begin = "#\\{"; end = "\\}"; patterns = ( { include = "source.ruby"; } ); },
	        	/*{ 
					name = "string.regexp.escaped.slash.ruby"; 
					match = "\\\\/"; 
					foregroundColor = "#CCCC33"; 
				},*/
				{ 
					name = "string.escaped.char.ruby"; 
					match = "\\\\."; 
				}
	    	);
	    },
	
	    { 
	    	/*
	    	regular expressions (literal):
	    	%r{<regexp>}<options>
	    	*/
			name = "string.regexp.ruby.mod-r"; 
			begin = "%r\\{"; 
			end = "\\}[eimnosux]*";  
	    	patterns = (
	        	{ 
					name = "string.regexp.escaped.char.ruby"; 
					match = "\\."; 
				},
	       		{ 
					name = "string.regexp.arbitrary-repitition.ruby"; 
					match = "\\{\\d+(,\\d+)?\\}"; 
				},
	        	/*{ 
					name = "string.interpolation.ruby"; 
					match = "#\\{([^\\}]*)\\}"; 
				},*/
				{ name = "string.interpolation.ruby"; begin = "#\\{"; end = "\\}"; patterns = ( { include = "source.ruby"; } ); },
	        	{ 
					name = "string.regexp.escaped.slash.ruby"; 
					match = "\\\\/"; 
				}
	    	);
	    },

	    { 
			/* 
			literal capable of interpolation:    
			%W(a b#{42}c) #-> ["a", "b42c"]
			%W(ab c\nd \\\)ef)
			
			%(#{42})  #->  "42"
			*/
			name = "string.literal.upper.ruby";
			begin = "%[QWSR]?\\("; 
			end = "\\)"; 
			swallow = "\\\\."; 
	    	patterns = (
	        	/*{
					name = "string.interpolation.ruby"; 
					match = "#\\{([^\\}]*)\\}"; 
				},*/
				{ name = "string.interpolation.ruby"; begin = "#\\{"; end = "\\}"; patterns = ( { include = "source.ruby"; } ); },
				{ 
					name = "string.escaped.char.ruby"; 
					match = "\\\\."; 
				}
	    	);
	    },

	    { 
			/* 
			literal incapable of interpolation:
			%w(a b#{42}c) #-> ["a", "b#{42}c"]
			%w(ab c\nd \\\)ef)
			*/
			name = "string.literal.lower.ruby"; 
			begin = "%[qws]\\("; 
			end = "\\)"; 
			swallow = "\\\\."; 
			patterns = (
				{ 
					name = "string.escaped.char.ruby"; 
					match = "\\\\\\)"; 
				}
			);
	    },

   	    { 
			/* 
			this rule exists only to prevent the 'keywods.variables.symbol.ruby'
			from matching non-symbol strings such as:
			Regexp::MULTILINE
			Amazon::Search::LOCALES.keys
			::Config::CONFIG
			::DL.callback
			*/
			name = "dummy.class-member.ruby"; 
			match = "((::)?([a-zA-Z_][a-zA-Z0-9_]*::)+|::)[a-zA-Z_][a-zA-Z0-9_?!]*";
		},

	    { 
	    	/* 
			symbols:
		    :BIG  :aBC  :AbC9  :symb  :_asd  :_9sd  :__=  :f00bar  :abc!
            :abc?  :abc=  :<<  :<  :>>  :>  :<=>  :<=  :>=  :%  :*  :**
            :+  :-  :&  :|  :~  :=~  :==  :===  :`  :[]=  :[]  :/  :-@
            :+@  :@aaa  :@@bbb
	    	*/
			name = "constant.symbol.ruby";
			/*
			explained:
			    1: generic symbols with ?,! or = behind, but not with => behind
			    2: == and ===
			    3: >, >> and >=
			    4: <, << and <=
			    5: <=>
			    6: %, &, `, / and |
			    7: * and **
			    8: ~ and =~
			    9: +, -, +@ and -@
			   10: [] and []=
			   11: instance- and class-variable symbols
			             1                             2    3      4      5   6         7       8   9      10       11                */
	 		match = ":(?>[a-zA-Z_]\\w*(?>[?!]|=(?!>))?|===?|>[>=]?|<[<=]?|<=>|[%&`/\\|]|\\*\\*?|=?~|[-+]@?|\\[\\]=?|@@?[a-zA-Z_]\\w*)";
	    },

		{ 
			/*
			multiline comments:
			*/
			name = "comment.block.embedded-doc.ruby"; 
			begin = "^=begin"; 
			end = "^=end"; 
			swallow = "\\\\."; 
		},
			
		{
			/*
			end of line comments:
			im code  #  im comment
			*/
			name = "comment.line.ruby"; 
			match = "#.*$"; 
			"fontStyle" = ( italic ); 
		},
		
		{
		    /*
		    __END__ marker
		    */
		    name = "string.program-block.ruby";
		    begin = "^__END__$"; end = "\\z";
		},
        
        {
            name = "string.here-doc.ruby";
            begin = "(?><<(\\w+))"; end = "^\\1";
            patterns = (
               {  begin = "^<<\\w+"; end = "$";
                  patterns = ( { include = "source.ruby"; } );
               }
            );
    
        }        
        
/*        {
            comment = "HERE document. There is no standard way to tell what the language within (if any) might be.";
            name    = "string.double-quoted.here-doc.ruby";
            begin   = "=\\s*<<\\s*(([a-zA-Z0-9_])+)\\s*$";
            end     = "^\\1$";
            swallow = "\\\\."; 
            captures = { 1 = { name = "keyword.ruby"; }; };
            
        }
*/
	);
	uuid = "E00B62AC-6B1C-11D9-9B1F-000D93589AF6";
}

